-- ***********************************
-- SQL ADVANCED 4
-- ***********************************

use [QLHD]
GO

select * from [dbo].[CTHD] 
--- [SOHD, MASP]: Pri key, SL: so luong

select * from [dbo].[HOADON] 
--- [SOHD]: Pri key [MAKH, MANV]: Foreign Key, NGHD: Ngay hop dong, TRIGIA: gia tri HD

select * from [dbo].[KHACHHANG] 
--- [MAKH]: Pri key, HOTEN: ho va ten, DCHI: dia chi kh, SODT: so dien thoai
--- NGSINH: Ngay sinh cua kh, NGDK: Ngay kh dang ky, DOANHSO: Doanh so thu duoc tu kh

select * from [dbo].[NHANVIEN] 
--- [MANV]: Pri key, HOTEN: Ten nhan vien, SODT: So dien thoai cua nv
---, NGVL: Ngay bat dau lam viec

select * from [dbo].[SANPHAM] 
--- [MASP]: Pri key, TENSP: Ten san pham, DVT: Don vi tinh, NUOCSX: Noi san xuat
---, GIA: gia thanh sp
GO

-----------------------------------------------
-- TASK 1: Trigger Insert, Update, Delete
-----------------------------------------------
-- TẠO TRIGGER ĐỂ CẬP NHẬT THÔNG TIN TRIGIA TRONG BẢNG HOADON 
-- TỪ VIỆC TÍNH TOÁN SL*GIA CỦA TỪNG MÃ SẢN PHẨM, 
-- ÁP DỤNG CHO 3 KIỂU THAY ĐỔI DỮ LIỆU LÀ INSERT, UPDATE, DELETE
-- TABLE: [CTHD], [HOADON], [SANPHAM] 
	CREATE TRIGGER TRIG_TRIGIA
	ON CTHD
	FOR INSERT, UPDATE, DELETE
	AS

		DECLARE @SOHD INT

		DECLARE CUR_SOHD CURSOR
		FOR SELECT SOHD FROM INSERTED 
			UNION SELECT SOHD FROM DELETED

		OPEN CUR_SOHD
		FETCH NEXT FROM CUR_SOHD INTO @SOHD
		WHILE @@FETCH_STATUS=0
		BEGIN
			UPDATE HOADON
			SET TRIGIA = (SELECT SUM(a.SL * b.GIA)
							FROM CTHD a
							LEFT JOIN SANPHAM b ON a.MASP = b.MASP
							WHERE SOHD = @SOHD)
			FETCH NEXT FROM CUR_SOHD INTO @SOHD
		END
		CLOSE CUR_SOHD
		DEALLOCATE CUR_SOHD
GO

-- CHECK TABLE
	SELECT * FROM SANPHAM
	SELECT * FROM CTHD
	SELECT * FROM HOADON

--TEST TRIGGER	
	BEGIN TRANSACTION
	-- Test INSERT CASE (ICASE)
		BEGIN TRANSACTION
		INSERT INTO CTHD (SOHD, MASP, SL) VALUES (1022, 'BB01', 10)
		ROLLBACK TRANSACTION
	-- Test DELETE CASE (DCASE)
		BEGIN TRANSACTION
		DELETE FROM CTHD WHERE SOHD=1022 AND MASP='BB01'
		ROLLBACK TRANSACTION
	-- Test UPDATE CASE (UCASE)
		BEGIN TRANSACTION
		UPDATE CTHD
		SET SL = 20 WHERE SOHD=1022 AND MASP='BB01'
		ROLLBACK TRANSACTION

-----------------------------------------------
-- TASK 2: Create Trigger Print notify
-- TẠO TRIGGER THÔNG BÁO NẾU SỐ LƯỢNG HÀNG TỒN KHO CỦA MASP <= 10 
-----------------------------------------------
-- TRONG TRƯỜNG HỢP XUẤT HÀNG > SL TỒN KHO -> HIỂN THỊ THÔNG BÁO VỀ SLSP CẦN NHẬP THÊM VÀ NUOCSX MASP ĐÓ.
-- TABLE: [CTHD], [WAREHOUSE_REMAINING]

    -- TẠO BẢNG [WAREHOUSE_REMAINING]
	SELECT DISTINCT MASP,
					50 AS QUANTITY INTO WAREHOUSE_REMAINING
	FROM CTHD
	-- VÍ DỤ:
	---- ‘MÃ SẢN PHẨM BB01 HIỆN CHỈ CÒN 6 SẢN PHẨM’
	---- ‘CẦN NHẬP THÊM 5 SẢN PHẨM MÃ BB02 TỪ TRUNG QUỐC’

-- || CÁCH 1 ||

GO
	CREATE TRIGGER TRIG_WH1
	ON CTHD
	FOR INSERT, UPDATE, DELETE
	AS
	-- CASE INSERT
	IF EXISTS (SELECT * FROM INSERTED) AND NOT EXISTS (SELECT * FROM DELETED)
		DECLARE @IMASP VARCHAR(4)
	
		DECLARE CUR_I CURSOR
		FOR SELECT MASP FROM INSERTED WHERE MASP NOT IN(SELECT MASP FROM DELETED)

		OPEN CUR_I
		FETCH NEXT FROM CUR_I INTO @IMASP
		WHILE @@FETCH_STATUS=0
		BEGIN
			DECLARE @INUOCSX VARCHAR(40)
			SET @INUOCSX = (SELECT NUOCSX 
							FROM SANPHAM
							WHERE MASP = @IMASP)
		
			DECLARE @ISL_CON_LAI INT
			SET @ISL_CON_LAI = (SELECT (a.QUANTITY - b.SL)
								FROM WAREHOUSE_REMAINING a
								LEFT JOIN INSERTED b ON a.MASP=b.MASP
								WHERE a.MASP=@IMASP)
	
			IF @ISL_CON_LAI < 0
				PRINT N'ICASE : CẦN NHẬP THÊM ' +CONVERT(VARCHAR(MAX),ABS(@ISL_CON_LAI)) +N' SẢN PHẨM MÃ ' +@IMASP+ N' TỪ ' + @INUOCSX
			
			IF @ISL_CON_LAI > 0
				UPDATE WAREHOUSE_REMAINING
				SET QUANTITY = @ISL_CON_LAI 
				WHERE MASP=@IMASP
				
			IF @ISL_CON_LAI BETWEEN 0 AND 10
				PRINT N'ICASE: MÃ SẢN PHẨM ' +@IMASP +N' HIỆN CHỈ CÒN ' +CONVERT(VARCHAR(MAX),@ISL_CON_LAI)+N' SẢN PHẨM'
			
			FETCH NEXT FROM CUR_I INTO @IMASP
		END -- OF WHILE
		CLOSE CUR_I
		DEALLOCATE CUR_I
	
	-- CASE UPDATE
	IF EXISTS (SELECT * FROM INSERTED) AND EXISTS (SELECT * FROM DELETED)
		DECLARE @UMASP VARCHAR(4)
	
		DECLARE CUR_U CURSOR
		FOR SELECT MASP FROM INSERTED WHERE MASP IN (SELECT MASP FROM DELETED)
	
		OPEN CUR_U
		FETCH NEXT FROM CUR_U INTO @UMASP
		WHILE @@FETCH_STATUS=0
		BEGIN
			DECLARE @UNUOCSX VARCHAR(40)
			SET @UNUOCSX = (SELECT NUOCSX 
								FROM SANPHAM
								WHERE MASP = @UMASP)
		
			DECLARE @USL_CON_LAI INT
			SET @USL_CON_LAI = (SELECT a.QUANTITY - (b.SL - c.SL)
								FROM WAREHOUSE_REMAINING a
								LEFT JOIN INSERTED b ON a.MASP=b.MASP
								LEFT JOIN DELETED  c ON b.MASP=c.MASP
								WHERE b.MASP=@UMASP)
	
			IF @USL_CON_LAI < 0
				PRINT N'UCASE: CẦN NHẬP THÊM ' +CONVERT(VARCHAR(MAX),ABS(@USL_CON_LAI)) +N' SẢN PHẨM MÃ ' +@UMASP+ N' TỪ ' + @UNUOCSX

			IF @USL_CON_LAI >0
				UPDATE WAREHOUSE_REMAINING
				SET QUANTITY = @USL_CON_LAI 
				WHERE MASP=@UMASP
			
			IF @USL_CON_LAI BETWEEN 0 AND 10
				PRINT N'UCASE: MÃ SẢN PHẨM ' +@UMASP +N' HIỆN CHỈ CÒN ' +CONVERT(VARCHAR(MAX),@USL_CON_LAI)+N' SẢN PHẨM'
			
			FETCH NEXT FROM CUR_U INTO @UMASP
		END -- OF WHILE
		CLOSE CUR_U
		DEALLOCATE CUR_U

	-- CASE DELETE
	IF NOT EXISTS (SELECT * FROM INSERTED) AND EXISTS (SELECT * FROM DELETED)
		DECLARE @DMASP VARCHAR(4)
	
		DECLARE CUR_D CURSOR
		FOR SELECT MASP FROM DELETED WHERE MASP NOT IN (SELECT MASP FROM INSERTED)
	
		OPEN CUR_D
		FETCH NEXT FROM CUR_D INTO @DMASP
		WHILE @@FETCH_STATUS=0
		BEGIN
			DECLARE @DNUOCSX VARCHAR(40)
			SET @DNUOCSX = (SELECT NUOCSX 
								FROM SANPHAM
								WHERE MASP = @DMASP)
		
			DECLARE @DSL_CON_LAI INT
			SET @DSL_CON_LAI = (SELECT (a.QUANTITY+b.SL)
								FROM WAREHOUSE_REMAINING a
								LEFT JOIN DELETED b ON a.MASP=b.MASP
								WHERE a.MASP=@DMASP)

			IF @DSL_CON_LAI < 0
				PRINT N'DCASE : CẦN NHẬP THÊM ' +CONVERT(VARCHAR(MAX),ABS(@DSL_CON_LAI)) +N' SẢN PHẨM MÃ ' +@DMASP+ N' TỪ ' + @DNUOCSX
			
			IF @DSL_CON_LAI >0
				UPDATE WAREHOUSE_REMAINING
				SET QUANTITY = @DSL_CON_LAI 
				WHERE MASP=@DMASP
				
			IF @DSL_CON_LAI BETWEEN 0 AND 10
				PRINT N'DCASE: MÃ SẢN PHẨM ' +@DMASP +N' HIỆN CHỈ CÒN ' +CONVERT(VARCHAR(MAX),@DSL_CON_LAI)+N' SẢN PHẨM'
			
			FETCH NEXT FROM CUR_D INTO @DMASP
		END --- OF WHILE
		CLOSE CUR_D
		DEALLOCATE CUR_D
GO	


-- CHECK TABLE
	SELECT * FROM CTHD
	SELECT * FROM WAREHOUSE_REMAINING

--TEST TRIGGER	
	BEGIN TRANSACTION
	-- Test INSERT CASE (ICASE)
		BEGIN TRANSACTION
		INSERT INTO CTHD(SOHD, MASP, SL) VALUES(4000, 'BB01', 55)
		ROLLBACK TRANSACTION
	-- Test DELETE CASE (DCASE)
		BEGIN TRANSACTION
		DELETE FROM CTHD WHERE SOHD=1014 AND SL=50
		ROLLBACK TRANSACTION
	-- Test UPDATE CASE (UCASE)
		BEGIN TRANSACTION
		UPDATE CTHD
		SET SL = 50 WHERE SOHD=1014 AND MASP='BB01'
		ROLLBACK TRANSACTION
	
	UPDATE WAREHOUSE_REMAINING
	SET QUANTITY = 50 WHERE MASP='BB01'

-- || CÁCH 2 ||
 GO
	CREATE TRIGGER TRIG_WH2
	ON CTHD
	FOR INSERT, UPDATE, DELETE
	AS

	-- CASE INSERT
	IF EXISTS(SELECT * FROM INSERTED) AND NOT EXISTS(SELECT * FROM DELETED)
		--//Declare Sub inserted table
		DECLARE @SUB_INSERTED_1 TABLE
		(
			MASP NVARCHAR(MAX),
			SL INT
		)
		--// insert data to SUB_INSERTED_1 table
		INSERT INTO @SUB_INSERTED_1
		SELECT MASP,
			   SUM(SL)
		FROM INSERTED
		GROUP BY MASP
		--// Declare MASP variable
		DECLARE @MASP NVARCHAR(MAX)
		--// Declare CURSOR
		DECLARE CUR CURSOR FOR
			SELECT DISTINCT MASP FROM @SUB_INSERTED_1
		--// Use CURSOR
		OPEN CUR
		FETCH NEXT FROM CUR INTO @MASP
		WHILE @@FETCH_STATUS =0
		BEGIN
			UPDATE WAREHOUSE_REMAINING
			SET QUANTITY = QUANTITY -
			  (SELECT SL
			   FROM @SUB_INSERTED_1
			   WHERE MASP = @MASP)
			WHERE MASP = @MASP 

			FETCH NEXT FROM CUR INTO @MASP
		END
		CLOSE CUR
		DEALLOCATE CUR

	-- CASE DELETE
	IF NOT EXISTS (SELECT * FROM INSERTED) AND EXISTS (SELECT * FROM DELETED)
		--//Declare Sub deleted table
		DECLARE @SUB_DELETED_1 TABLE
			(
				MASP NVARCHAR(MAX),
				SL INT
			)
		--// instert data to sub deleted table
		INSERT INTO @SUB_DELETED_1
		SELECT MASP,
			   SUM(SL)
		FROM DELETED
		GROUP BY MASP
		--// delcare CURSOR
		DECLARE CUR CURSOR FOR
			SELECT DISTINCT MASP FROM @SUB_DELETED_1
		--// using CUROR
		OPEN CUR
		FETCH NEXT FROM CUR INTO @MASP
		WHILE @@FETCH_STATUS =0
		BEGIN
			UPDATE WAREHOUSE_REMAINING
			SET QUANTITY = QUANTITY +
			  (SELECT SL
			   FROM @SUB_DELETED_1
			   WHERE MASP = @MASP)
			WHERE MASP = @MASP
			
			FETCH NEXT FROM CUR INTO @MASP
		END
		CLOSE CUR
		DEALLOCATE CUR

	-- CASE UPDATE
	IF EXISTS(SELECT * FROM INSERTED) AND EXISTS(SELECT * FROM DELETED)
		--//declare sub instered table
		DECLARE @SUB_INSERTED_2 TABLE
		(
			MASP NVARCHAR(MAX),
			SL INT
		)
		--// instert data to sub inserted table
		INSERT INTO @SUB_INSERTED_2
		SELECT MASP,
			   SUM(SL) SL
		FROM INSERTED
		GROUP BY MASP

		--//declare sub deleted table
		DECLARE @SUB_DELETED_2 TABLE
		(
			MASP NVARCHAR(MAX),
			SL INT
		)
		--// insert data to sub deleted table
		INSERT INTO @SUB_DELETED_2
		SELECT MASP,
			   SUM(SL) SL
		FROM DELETED
		GROUP BY MASP

		--// declare Join inserted and deleted table
		DECLARE @JOIN_INSERTED_DELETED TABLE
		(
			MASP NVARCHAR(MAX),
			SL_INSERTED INT,
			SL_DELETED INT,
			QUANTITY_EXPORTED INT
		)
		--// insert data to Join inserted and deleted table
		INSERT INTO @JOIN_INSERTED_DELETED
		SELECT CASE
				WHEN A.MASP IS NULL
					AND B.MASP IS NOT NULL THEN B.MASP
				WHEN A.MASP IS NOT NULL
					AND B.MASP IS NULL THEN A.MASP
				ELSE A.MASP
			END AS MASP,
			CASE
				WHEN A.MASP IS NULL THEN 0
				ELSE A.SL
			END AS SL_INSERTED,
			CASE
				WHEN B.MASP IS NULL THEN 0
				ELSE B.SL
			END AS SL_DELETED,
			(CASE
				WHEN A.MASP IS NULL THEN 0
				ELSE A.SL
			END) - (CASE
						WHEN B.MASP IS NULL THEN 0
						ELSE B.SL
					END) AS QUANTITY_EXPORTED
		FROM @SUB_INSERTED_2 A
		FULL OUTER JOIN @SUB_DELETED_2 B ON A.MASP = B.MASP
		--// declare CURSOR
		DECLARE CUR CURSOR FOR
			SELECT DISTINCT MASP FROM @JOIN_INSERTED_DELETED
		--// using CURSOR
		OPEN CUR
		FETCH NEXT FROM CUR INTO @MASP
		WHILE @@FETCH_STATUS = 0
		BEGIN
			UPDATE WAREHOUSE_REMAINING
			SET QUANTITY = QUANTITY -
			  (SELECT QUANTITY_EXPORTED
			   FROM @JOIN_INSERTED_DELETED
			   WHERE MASP = @MASP)
			WHERE MASP = @MASP

			FETCH NEXT FROM CUR INTO @MASP
		END
		CLOSE CUR
		DEALLOCATE CUR

-----------------------------------------------
--3. TẠO TRIGGER CẬP NHẬT DỮ LIỆU WAREHOUSE =======>>> ĐÃ XỬ LÝ TRONG BÀI 2
-----------------------------------------------
--KHI MÀ THÔNG TIN HỢP ĐỒNG ĐƯỢC CẬP NHẬT VÀO TRONG CTHD
---- TẠO BẢNG HÀNG TỒN KHO (WAREHOUSE):
		SELECT DISTINCT MASP, 50 AS QUANTITY INTO WAREHOUSE_REMAINING
		FROM CTHD
